OUTPUT_DIR ?= fleet
YQ ?= yq
DASEL ?= dasel
PYTHON ?= python3
KPT ?= kpt
FIX_TOML ?= $(CURDIR)/bin/fix-toml-multiline.py
FLEET_REMOTE ?= fleet
FLEET_BRANCH ?= flox-subtree
SETTERS_IMAGE ?= gcr.io/kpt-fn/apply-setters:v0.4.1
SETTERS_CONFIG ?= setters.yaml
FLEET_BASE_DIR ?= /var/lib/git/nxmatic/fleet/flox

SHELL := bash
.SHELLFLAGS := -exu -o pipefail -c
.ONESHELL:

.PRECIOUS: $(OUTPUT_DIR)/%/.flox/env $(BUILD_YAML)

FLOX_ENV_FILES := $(filter-out kustomization.yaml Kptfile setters.yaml,$(wildcard *.yaml))
FLOX_ENV_NAMES := $(basename $(notdir $(FLOX_ENV_FILES)))
PKG_SOURCES := Kptfile $(SETTERS_CONFIG) $(FLOX_ENV_FILES)
BUILD_YAML := $(OUTPUT_DIR)/.kustomize/flox.yaml
FLEET_DESCRIPTOR := $(OUTPUT_DIR)/flox-envs.yaml
ENV_DESCRIPTOR_TARGETS := $(foreach name,$(FLOX_ENV_NAMES),$(OUTPUT_DIR)/$(name).yaml)

MANIFEST_TARGETS := $(addprefix $(OUTPUT_DIR)/,$(addsuffix /.flox/env/manifest.toml,$(FLOX_ENV_NAMES)))
ENV_JSON_TARGETS := $(addprefix $(OUTPUT_DIR)/,$(addsuffix /.flox/env.json,$(FLOX_ENV_NAMES)))
RENDER_TARGETS := $(MANIFEST_TARGETS) $(ENV_JSON_TARGETS) $(FLEET_DESCRIPTOR) $(ENV_DESCRIPTOR_TARGETS)

.PHONY: all render clean-dist check-tools fleet-remote fleet-pull fleet-push set-fleet-base-dir do-render
set-fleet-base-dir:
	$(YQ) --inplace eval '.data["fleet-base-dir"] = "$(FLEET_BASE_DIR)"' "$(SETTERS_CONFIG)"
	$(KPT) fn render "$(CURDIR)"

all: render

render: check-tools
render: clean-dist
render: do-render
render:
	: "[render] applied"

do-render: $(RENDER_TARGETS)
	touch "$(OUTPUT_DIR)/.placeholder"

clean-dist:
	rm -rf "$(OUTPUT_DIR)"

check-tools:
	missing="";
	for cmd in $(KPT) $(YQ) $(DASEL); do
	  if ! command -v $$cmd >/dev/null 2>&1; then
	    missing="$$missing $$cmd";
	  fi;
	done;
	if [[ -n "$$missing" ]]; then
	  echo "Missing required commands:$$missing" >&2;
	  exit 1;
	fi;

$(BUILD_YAML): $(PKG_SOURCES)
	mkdir -p "$(dir $@)"
	$(KPT) fn render "$(CURDIR)" -o unwrap > "$@"

$(OUTPUT_DIR)/%/.flox/env:
	mkdir -p "$@"

$(OUTPUT_DIR)/%/.flox/env/manifest.toml: $(BUILD_YAML) | $(OUTPUT_DIR)/%/.flox/env
	NAME="$*" \
	$(YQ) eval '
	  select(.kind == "FloxEnvironment" and .metadata.name == env(NAME)) |
	  (.spec.manifest.install // {}) as $$install |
	  .spec.manifest.install = (
	    $$install |
	    with_entries(
	      .value |= (
	        (. // {}) |
	        . * {
	          "pkg-group": (
	            (
	              .pkg-group |
	              select(. != null) |
	              (env(NAME) + "-" + .)
	            ) // env(NAME)
	          )
	        }
	      )
	    )
	  ) |
	  .spec.manifest
	' "$(BUILD_YAML)" | \
		$(DASEL) -r yaml -w toml -f /dev/stdin > "$@"
	$(PYTHON) "$(FIX_TOML)" "$@"

$(OUTPUT_DIR)/%/.flox/env.json: $(BUILD_YAML) | $(OUTPUT_DIR)/%/.flox/env
	$(YQ) eval "select(.kind == \"FloxEnvironment\" and .metadata.name == \"$*\") | .spec.env" "$(BUILD_YAML)" | \
		$(DASEL) -r yaml -w json -f /dev/stdin > "$@"

$(FLEET_DESCRIPTOR): $(BUILD_YAML)
	printf "# Generated by flox-shared-environments make render\n---\n" > "$@"
	env  FLEET_BASE_DIR="$(FLEET_BASE_DIR)" \
	$(YQ) eval -o=yaml -I 2 '
	  {"apiVersion":"nxmatic.dev/v1alpha1","kind":"FloxEnvironmentDescriptor",
	   "environments": ([
	     select(.kind == "FloxEnvironment") |
	     {
	       "name": .metadata.name,
	       "source": (.metadata.annotations."flox.dev/source" // ("" + .metadata.name + ".yaml")),
	       "manifest": "flox/" + .metadata.name + "/.flox/env/manifest.toml",
	       "envJson": "flox/" + .metadata.name + "/.flox/env.json",
	       "includes": ((.spec.manifest.include.environments // []) | map(.dir)),
	       "localIncludes": ((.spec.manifest.include.environments // []) | map(.dir | sub("^" + env(FLEET_BASE_DIR) + "/", "")))
	     }
	   ])
	  }
	' "$(BUILD_YAML)" >> "$@"

$(ENV_DESCRIPTOR_TARGETS): %.yaml: $(BUILD_YAML)
$(ENV_DESCRIPTOR_TARGETS): %.yaml: $(BUILD_YAML)
	mkdir -p "$(dir $@)"
	printf "# Generated by flox-shared-environments make render\n---\n" > "$@"
	env FLEET_BASE_DIR="$(FLEET_BASE_DIR)" \
		NAME="$$(basename "$@" .yaml)" \
		$(YQ) eval -o=yaml -I 2 '
	  select(.kind == "FloxEnvironment" and .metadata.name == env(NAME)) |
	  {"apiVersion":"nxmatic.dev/v1alpha1","kind":"FloxEnvironment",
	   "name": .metadata.name,
	   "source": (.metadata.annotations."flox.dev/source" // ("" + .metadata.name + ".yaml")),
	   "manifest": "flox/" + .metadata.name + "/.flox/env/manifest.toml",
	   "envJson": "flox/" + .metadata.name + "/.flox/env.json",
	   "includes": ((.spec.manifest.include.environments // []) | map(.dir)),
	   "localIncludes": ((.spec.manifest.include.environments // []) | map(.dir | sub("^" + env(FLEET_BASE_DIR) + "/", ""))),
	   "packages": (.spec.manifest.install // {} | keys)
	  }
	' "$(BUILD_YAML)" >> "$@"

fleet-remote:
	@if ! git remote get-url "$(FLEET_REMOTE)" >/dev/null 2>&1; then
	  git remote add "$(FLEET_REMOTE)" git@github.com:nxmatic/fleet-manifests.git;
	fi

fleet-pull: fleet-remote
	git subtree pull --prefix="$(OUTPUT_DIR)" "$(FLEET_REMOTE)" "$(FLEET_BRANCH)" --squash

fleet-push: fleet-remote render
	@if ! git -C "$(CURDIR)" diff --quiet HEAD -- "$(OUTPUT_DIR)"; then
	  echo "Uncommitted changes detected under $(OUTPUT_DIR). Please commit or stash them before pushing." >&2;
	  exit 1;
	fi
	@untracked="$$(git -C "$(CURDIR)" ls-files --others -- "$(OUTPUT_DIR)" --exclude-standard)";
	if [[ -n "$$untracked" ]]; then
	  echo "Untracked files detected under $(OUTPUT_DIR). Please add or clean them before pushing." >&2
	  exit 1
	fi
	@split_sha="$$(git -C "$(CURDIR)" subtree split --prefix="$(OUTPUT_DIR)" HEAD)"
	remote_sha="$$(git -C "$(CURDIR)" ls-remote --heads "$(FLEET_REMOTE)" "$(FLEET_BRANCH)" | awk '{print $$1}')" || true
	if [[ -n "$$remote_sha" && "$$split_sha" == "$$remote_sha" ]]; then
	  echo "No new fleet revisions to push; skipping subtree push."
	else
	  git -C "$(CURDIR)" subtree push --prefix="$(OUTPUT_DIR)" "$(FLEET_REMOTE)" "$(FLEET_BRANCH)"
	fi
